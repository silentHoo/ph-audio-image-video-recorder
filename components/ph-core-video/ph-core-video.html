<link rel="import" href="../polymer/polymer.html">

<!-- mixins for shared functionality -->
<link rel="import" href="../ph-polymer-mixins/mixins-core.html">
<link rel="import" href="../ph-polymer-mixins/mixins-audiovideo.html">

<!--
This component gives basic functionality to record from a given `getUserMedia` stream.

Before you start recording from the stream, please first check if the current browser has support for the Web APIs used
by `ph-core-image`. You must simply call `isSupported()`. You can start and stop recording of the stream and get the
recorded stream as a WebM blob created by Whammy (JavaScript WebM Encoder).

@group Core Elements
@element ph-core-video
@homepage https://silenthoo.github.io/ph-core-video
@demo https://silenthoo.github.io/ph-core-video/demo.html
-->

<!--
WebM Video Encoder Library: Whammy.js

Copyright (C) 2013 Kevin Kwok

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<script src="../whammy/whammy.js"></script>

<polymer-element name="ph-core-video" extends="ph-core-image" constructor="PhCoreVideo" attributes="">
  <script>
    (function () {

      Polymer(Polymer.mixin({
        _videoBlob: null,           // the video blob generated by Whammy in WebM format
        _videoFrames: [],           // the single frames from the canvas
        _rafId: null,               // requestAnimationFrame id
        _fps: 0,                    // frames per second
        _recordedCallback: null,    // callback provided by consumer

        /**
         * Returns `true` if this component is supported by the current used browser. False otherwise.
         *
         * @return {boolean} true if the browser is supported, false otherwise.
         */
        isSupported: function() {
          return this.super();
        },

        /**
         * Sets the callback which will be invoked when the recording has stopped and the recorded blob is requested.
         *
         * @param {onBlobReady} The callback which will be called when the blob is ready.
         */
        getRecordedBlob: function(onBlobReady) {
          this._recordedCallback = onBlobReady;

          if (this._videoBlob !== null) {
            // call callback if videoblob is already produced
            this._onBlobReady();
          }
        },

        /**
         * Callback used to call the invoker, when the proceeding of the video blob has finished after the recording
         * was stopped.
         *
         * @callback onBlobReady
         * @param videoInfo Information about the recorded video.
         * @param videoInfo.blob The videoBlob in WebM format produced by Whammy.
         * @param videoInfo.frames The total number of frames.
         * @param videoInfo.fps The framecount per second (fps).
         */

        // ===== private methods =====

        // invoked when the internal state changes (state injected by mixins)
        _stateChanged: function() {
          switch (this._state) {
            case this._stateEnum.RECORDING:
              this._onRecordingStarted();
              break;
            case this._stateEnum.STOPPED:
              this._onRecordingStopped();
              break;
            default:
              break;
          }
        },

        _onRecordingStarted: function() {
          this._videoBlob = null; // reset blob
          this._recordedCallback = null,
          this._videoFrames = [];

          // draw the current video frame into the canvas 2D context to read them back as image.
          function drawVideoFrame() {
            this._rafId = requestAnimationFrame((drawVideoFrame).bind(this)); // cross browser safe!
            //this._canvas.getContext('2d').drawImage(this._id('#liveVideo'), 0, 0, this._canvas.width, this._canvas.height);
            this._drawImage();

            // Read back canvas as webp.
            var url = this.getPictureDataURL('image/webp', 0.80);
            this._videoFrames.push(url);
          };

          // request the first frame
          this._rafId = requestAnimationFrame((drawVideoFrame).bind(this));
        },

        _onRecordingStopped: function() {
          cancelAnimationFrame(this._rafId);
          // adjust the recorded frames to the duration to get the real speed
          this._fps = Math.floor(this._videoFrames.length / (this.getDuration() / 1000));

          this.async(function() {
            this._videoBlob = Whammy.fromImageArray(this._videoFrames, this._fps);
            if (this._recordedCallback !== null) {
              // call callback if callback is already set
              this._onBlobReady();
            }
          });
        },

        _onBlobReady: function() {
          var videoInfo = {
            blob: this._videoBlob,
            frames: this._videoFrames.length,
            fps: this._fps
          };
          this._recordedCallback(videoInfo);
        }
      }, mixinsCore, mixinsAudioVideo));

    })();
  </script>
</polymer-element>
